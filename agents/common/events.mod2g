use commonKnowledge as knowledge.
use adoptGoals as module.
use updateSequence as module.
order=linearall.

module events {
	% Sometimes not all other agents are passed along at the init.
	if percept( player(X) ), not(bel( agent(X) )) then insert( agent(X) ). 
	
	% Update the agent's state of movement.
	forall bel( state(State)), percept(state(NewState))  
		do delete( state(State) ) + insert( state(NewState) ).
	
	% Record where we are.
	forall percept(at(Place)), bel(at(OldPlace)) do delete( at(OldPlace) ) + insert( at(Place) ).
	
	% Record when we are entering or leaving a room.
	forall percept(in(Place)) do insert( in(Place) ).
	forall percept(in(Place)), bel( not(visited(Place)), room(Place) ) do insert( visited(Place) ).
	forall percept(not(in(Place))) do delete( in(Place) ).

	% Discover new blocks
	forall percept(color(BlockID, ColorID)), bel( in(Place), not(block(BlockID, ColorID, Place)),
		block(BlockID, ColorID, OtherPlace), Place \= OtherPlace ) do 
		delete( block(BlockID, ColorID, OtherPlace) ) + insert( block(BlockID, ColorID, Place) ).
	forall percept(color(BlockID, ColorID)), bel( in(Place), not(block(BlockID, ColorID, Place)) ) 
		do insert( block(BlockID, ColorID, Place) ).
	
	% Record atblock location of agent
	forall percept(atBlock(BlockID)) do insert(atBlock(BlockID)).
	forall percept(not(atBlock(BlockID))) do delete(atBlock(BlockID)).
	
	% Record if a block is being held
	forall percept(holding(BlockID)) do insert(holding(BlockID)).
	forall percept(not(holding(BlockID))) do delete(holding(BlockID)).
	
	%remove blocks that are not held or in the room anymore
	forall bel(in(Place), block(BlockID, ColorID, Place), not(holding(BlockID))), 
		not(percept(color(BlockID, ColorID))) do delete(block(BlockID, ColorID, Place)).
	
	% Update sequence when in dropzone.
	if percept(sequenceIndex(X)), bel(sequenceIndex(OldX)) 
		then delete(sequenceIndex(OldX)) + insert(sequenceIndex(X)).
	% By using length with an ununified list we define the length of the list with unified variables.
	% The following append then unifies the list to the first X atoms of the Full sequence.
	if bel( in('DropZone'), seqDone(Seq), length(Seq, N), sequenceIndex(X), N < X , 
		sequence(Full), length(NewSeq, X), append(NewSeq, _, Full) )
		then delete( seqDone(Seq) ) + insert( seqDone(NewSeq) ).
				
	%remove obsolete goals
	if goal(holding(BlockID)), bel(not(block(BlockID, ColorID, Place))) then insert( stop ) + 
		drop(holding(BlockID)).
	if goal(in(Place), holding(BlockID)), bel(not(block(BlockID, ColorID, Place))) then insert( stop )
		+ drop(holding(BlockID)).
	if goal( in('DropZone') ), bel( not(holdingNextBlock) ) then insert( stop ) + 
		drop( in('DropZone') ).
	if bel( stop, state(traveling)) then delete( stop, state(traveling) ) + insert( state(stopped) ).
	if bel( stop ) then delete( stop ). 
	
	%adopt new goals (and stop traveling)		
	if not(goal(in(Place); at(Place))), goal(seqDone(_)) then adoptgoals.
}
