#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "breaklines=true,frame=single,language=Prolog,numbers=left"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Thesis
\end_layout

\begin_layout Author
Joris Z.
 van den Oever
\end_layout

\begin_layout Abstract
To be written
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Problem Statement
\end_layout

\begin_layout Standard
Robotic systems have been getting more mobile and prevalent in recent years.
 And with that comes new possibilities and uses.
 One project trying to take advantage of this is the TRADR project, Long-Term
 Human-Robot Teaming for Robot-Assisted Disaster Response
\begin_inset CommandInset citation
LatexCommand cite
key "kruijff2015tradr"

\end_inset

.
 It aims to create teams of robots and humans that work together to provide
 incidence response.
 Research into robot team communication is what prompted this research.
\end_layout

\begin_layout Standard
Autonomous robots in in disaster areas, including the industrial areas given
 by the TRADR use cases, need to be able to cooperate amongst themselves
 and with humans
\begin_inset CommandInset citation
LatexCommand cite
key "kruijff2015tradr"

\end_inset

.
 However because of the mobile nature of such robots this raises new questions
 about what happens when communication becomes unreliable.
 Wireless signals may not reach everywhere
\begin_inset CommandInset citation
LatexCommand cite
key "micheli2015measurement,cisco"

\end_inset

 and wired communication isn't generally feasible when staying mobile.
\end_layout

\begin_layout Standard
This requires us to look closer at the effects of having communication fail.
 While it is easy to presume that this will have undersired effects it is
 hard to predict what effects that will be.
 Only once these effects, if they exist, have been measured we can look
 at potential mitigation strategies.
 And of course determine their effectiveness.
\end_layout

\begin_layout Subsection
Research Questions
\end_layout

\begin_layout Standard
To this end we will provide answers to the following questions:
\end_layout

\begin_layout Itemize
What are the effects of communication failure of multi-agent team effectiveness
 at performing multi-stage tasks?
\end_layout

\begin_layout Itemize
How can we make multi-agent teams resilient to the negative effects of communica
tion failure on performing tasks?
\end_layout

\begin_layout Standard
Here we define a single instance communication failure as the recipient
 not reading a message that was sent to it by the sender.
 Irregardless of where in the transmission process the failure occured,
 e.g.
 while sending or receiving.
 And effectiveness is both the amount of times it successfully completes
 the task, and the time taken to complete the task.
\end_layout

\begin_layout Subsection
Research approach
\begin_inset CommandInset label
LatexCommand label
name "sub:Research-approach"

\end_inset


\end_layout

\begin_layout Standard
To gather the data we will create simulations of agent teams enduring communicat
ion failure.
 To run the simulations we will use a well explored domain for multi-agents
 systems: the Blocks World for Teams (BW4T) GOAL environment.
 It is a well defined domain for doing research on multi-agent systems.
\begin_inset CommandInset citation
LatexCommand cite
key "johnson2009joint"

\end_inset

 The basic concept is that an agent, or multiple agents, have to bring blocks
 to a certain place, the dropzone in a specific order.
 The blocks are distinguished by color only so any block that is the right
 color will suffice.
 These blocks are found in rooms that have one entrance from the hallway
 spaces.
 While that is the basic scenario it has built in several option for adjusting
 various environment variables such as the room placement.
 How the simulations are set up exactly is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Experiment-Design"

\end_inset

.
 
\end_layout

\begin_layout Standard
The BW4T environment is very suitable for investigating communication failure
 while doing multi-stage tasks because of several reasons.
 It implements a simple multi-stage task that can be completed without communica
tion but teams are faster when agents do communicate.
 The environment only contains elements relevent to the multi-stage task
 and can be controlled.
 And GOAL is an open source programming language specially made for multi-agent
 systems often used with BW4T.
 So there already exist a lot of agents that can be used, either for the
 research or as examples.
 As well as GOAL having a robust agent communication support.
\end_layout

\begin_layout Standard
The simulations will be done in two parts.
 The first part will be exploratory; using pre-existing agent teams made
 to solve BW4T scenearios.
 These agents have been without considering communication failure and will
 help identify potential stumbling blocks.
 The second part uses a set of specifically designed agents to control for
 different solving strategies and more closely evaluate the effects of different
 kinds of communication.
\end_layout

\begin_layout Standard
The differences in effectiveness from the second part will be used to see
 if the effects differ depending on how the communication fails and how
 well different agent strategies deal with the failure.
 This will all be simulated as it allows for stricter control of the experimenta
l dimensions in addition to making it easier to perform a large amount experimen
t runs for each scenario.
 Afterwards the results of the simulations can be compared to baselines
 where no communication failure is happening to answer the first research
 question.
 Then based on the data we can see where the effects are strongest, and
 if there are agents that work well in different situations.
 From these we can identify potential mitigation strategies.
 Which can be simulated in the same scenarios as before to compare their
 effectiveness and answer the second question.
\end_layout

\begin_layout Standard
The gathered data will be analysed using Chi square analysis to determine
 if the results are significantly different from the reference data.
 This will give us two analyses using both the one agent team baseline and
 the no communication team.
 This comparison we will only look at the rate of task completion within
 the timeout period.
 
\end_layout

\begin_layout Standard
If this shows there are indeed significant differences we can look for the
 effect the different communication failure scenarios on task completion
 time.
 As a first step regression analysis can see if there is an effect using
 both the type of team, size of the team, and the failure scenarios as independe
nt variables.
 Pending determination on if they have a signicant effect on the task completion
 rate.
 As an additional analysis to if there is a difference in how the different
 team types are affected each team type will have a separate regression
 analysis using the team size and failure scenarios.
 The same analysis will be done using the task completion time as the dependent
 variable.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
Multi-agent systems and how the agents interact is a field that has been
 explored from many angles.
 (EXAMPLES).
 The BW4T testbed focuses on joint activities based on a simple planning
 problem adapted for multi-agent systems
\begin_inset CommandInset citation
LatexCommand cite
key "johnson2009joint"

\end_inset

.
 It applies few restrictions on the agent teams performing in the environment
 allowing research on various aspects of coordination, planning, and interaction
 between agents
\begin_inset CommandInset citation
LatexCommand cite
key "johnson2012autonomy,wei2014multi,wei2014role,harbers2011explanation"

\end_inset

.
 Communication is important for these problems but much of the research
 in that direction relates to human-agent interaction
\begin_inset CommandInset citation
LatexCommand cite
key "harbers2012enhancing,harbers2011explanation"

\end_inset

.
 After all in a purely digital environment much more can be done to ensure
 messages are transmitted properly.
\end_layout

\begin_layout Standard
Multi-robot systems have physical contraints that influence how and when
 messages can be sent.
 As such there is research done on implicit communication
\begin_inset CommandInset citation
LatexCommand cite
key "kube1993collective"

\end_inset

 or how to effectively utilised limited and/or shared communication channels
\begin_inset CommandInset citation
LatexCommand cite
key "rybski2002performance"

\end_inset

.
 This is becoming more relevant with there appearing to be a trend of multi-agen
t systems growing in size and complexity.
 Such as the drone delivery systems currently in development for various
 companies
\begin_inset CommandInset citation
LatexCommand cite
key "zhou2014unmanned"

\end_inset

.
\end_layout

\begin_layout Standard
These systems are expected to deal with unreliable communication at least
 some of the time and research is already being done to see how the communicatio
n systems can be made more reliable
\begin_inset CommandInset citation
LatexCommand cite
key "winfield2000distributed,parker1998alliance"

\end_inset

.
 However this research is mostly done from a perspective of detecting that
 a fault has happened or making sure that the communication systems work.
 Rather than investigating what happens when communication fails.
 
\end_layout

\begin_layout Section
Experiment Design
\begin_inset CommandInset label
LatexCommand label
name "sec:Experiment-Design"

\end_inset


\end_layout

\begin_layout Standard
The experiment will consist of multiple simulation runs in the BW4T environment.
 Each simulation run requires an agent team to move around in a 2D environment
 to pick up and deliver blocks to a room called the dropzone in a given
 colour sequence.
 These blocks have to be found in other rooms in the 2D environment.
\end_layout

\begin_layout Standard
In this section we will discuss our choices for the environment variables
 such as topology, block sequences, communication failure, and team composition.
 The design of the agents themselves is discussed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Agent-Design"

\end_inset

.
 First the variables will be classified in the different experiment dimensions
 and then we will discuss how the variables will be reduced and why.
\end_layout

\begin_layout Subsection
Experiment Dimensions
\end_layout

\begin_layout Standard
We have categorised the variables, involved in the above mentioned experimental
 setup into three dimensions, environment, agents, and communication failure.
 There are several variables in each category as show in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:experiment dimensions"

\end_inset

.
 
\end_layout

\begin_layout Standard
Environment is simulation topology, the sequence used, and optional rules
 the agents function with.
 Currently the only optional rule available there are agent collisions.
 By default agents do not collide with each other and with this turned on
 they would.
 However it would only result in additional complexity to the agents while
 it could be solved without communication.
 As such it is not revelent to our research questions and do not have to
 consider it in our experiment.
\end_layout

\begin_layout Standard
Second are the agents themselves.
 Aside from the agent programs the team size can be adjusted, as well as
 the team composition.
 The former is the amount of agents present in the simulation, limited by
 the amount of computing power available and map capacity.
 Though topology limitations, such as rooms allowing no more than one agent
 in a room, might limit the effectiveness of a team larger than the amount
 of rooms available or than there are blocks in the sequence.
 The latter is if the teams are homogenous or not.
 As more than one agent program can be running in a team.
\end_layout

\begin_layout Standard
Finally there is the communication and how it can fail.
 Does the sending or receiving fail.
 Because if sending fails nobody gets the message and if receiving fails
 a subset of agents does not get the message.
 If it does fail is it a fixed percentage of messages that fails? Or does
 the failure rate increase over time? is the message more likely to fail
 if the receipient is further away? However because the intent is to find
 the effects of the failure and not the communication systems themselves
 the simplest model shall be used, a fixed percentage communication failure.
 
\end_layout

\begin_layout Standard
Aside from the model of communication failure the communication with the
 BW4T environment should be considered too.
 As it provides updates on the task progress when a block is delivered correctly.
 This could effectively be a side-channel for task updates that always succeeeds.
 As such agents should ignore those task updates and only the normal communcatio
n channels.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Environment
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Topology
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Block sequence
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Agents
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Team size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hetero-/homogenous teams
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Communication Failure
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Send/receiving failure
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Failure chance
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:experiment dimensions"

\end_inset

Experiment dimensions before reduction
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Experiment reduction
\begin_inset CommandInset label
LatexCommand label
name "sub:Experiment-reduction"

\end_inset


\end_layout

\begin_layout Standard
The above mentioned experiment dimensions have too many options to realistically
 test everything.
 However not everything needs to be tested, some of the variables only need
 a subset tested or can be eliminated by only using one of the options.
 How and why this is done will be discussed per dimension in the subsections
 below.
\end_layout

\begin_layout Subsubsection*
Environment
\end_layout

\begin_layout Standard
The map topology consists of several components, the size of the map, room
 placement, block placement, and corridor placement.
 
\end_layout

\begin_layout Standard
The size of the map is how big the map is overal.
 Bigger maps can have more rooms, larger spaces, and can accomodate more
 agents.
 Room placement decides how many rooms there are and where on the map they
 are placed, as well as their size.
 More rooms means more places for blocks and more places that agents need
 to look to find the blocks they need.
 Block placement defines the rooms blocks are in and how many blocks there
 are.
 If not all blocks in the sequence are present the simulation can not end.
 Blocks disappear if they are delivered at the wrong time.
 As such it also determines how many 'spare' blocks there are present to
 cover for incorrect deliveries.
 Corridor placement determine the spaces agents have to move around in between
 rooms.
 These determine how many routes there are for agents to take.
\end_layout

\begin_layout Standard
Map size can be kept consistent if we make it big enough to contain all
 the variations we need, it does not need to be changed after that.
 The amount of rooms only influences how many options agents have to look
 at and how far they have to move to reach the rooms.
 Varying this does not change what needs to be communicated as such only
 one appropriate number needs to be chosen.
 Corridors just need to connect the rooms that exist with the dropzone.
 As such a single configuration is needed.
 This means that all maps can be the same aside from the block placement.
 We can already exclude all block placements that make the sequence impossible.
 
\color red
(Chris identified 12 block placement scenarios and made maps for them.
 How to correctly refer to that?)
\color inherit
 These 6 maps are all the same aside from block placement and lets us reduce
 the topology to 12 options.
\end_layout

\begin_layout Standard
For the sequence options there are two big distinctions for our purposes.
 All blocks are the same or they can differ.
 When all blocks are the same it does not matter what order they are delivered
 in as all blocks of the same colour are equal.
 This means that the current block in the sequence doesn't matter.
 Only if the task is finished or not.
 This means that the agents will not have to communicate about the intermediate
 steps.
 Whereas the other option does require communicating intermediate task completio
n.
 As such sequences where the blocks can differ will be used.
 However there are enough colours that the sequence can does not have to
 contain repeating colours.
 However not all combinations here have to be tried as we just need a sequence
 where all colours are different and a sequence where there are duplicate
 blocks.
 Giving us 2 options for the sequence.
\end_layout

\begin_layout Subsubsection*
Agents
\end_layout

\begin_layout Standard
Outside the agent programming there are two variables affecting agents,
 the size of the agent teams and the team composition.
\end_layout

\begin_layout Standard
Limiting the sizes used for the agent teams will significantly reduce the
 experiment space as this is limited only by what the hardware can process.
 By taking a sampling of the team sizes we can get a sense of the effects,
 if there are any, communication failures might have.
 
\end_layout

\begin_layout Standard
The case of having only 1 agent, would not need a lot of experimentation
 as there is nothing to communicate with, however it will still be useful
 to do once to get a effectiveness baseline for the agents.
 
\end_layout

\begin_layout Standard
Next, using a size sample of 3 agents will be useful to test, as this is
 the minimum amount of agents needed to have a team where it is possible
 to communicate with more than one agent at the same time.
 Which is needed to see the effects of what happens with the cooperative
 agents when only some of the agents' responses for task distribution arrives.
 Ensuring this effect exists for all team sizes.
\end_layout

\begin_layout Standard
The third team size would be 5 agents, as this is a larger group, but is
 also just a bit more than half the amount of rooms available in the default
 map setup and one less than the amount of blocks needed in the sequence.
 This means the way tasks get divided amongst agents becomes important.
 As not every agent can continue exploring after just one set of rooms.
 As well as increasing the amount of agents involved in communicating.
 
\end_layout

\begin_layout Standard
The final team size should not go too far, as experience with the environment
 has shown that 8 agents start to tax the hardware available to us and might
 degrade the simulation.
 This will also make teams with a size close to the amount of rooms available
 and it might be interesting to see how that influences the behaviour.
 As such going one agent fewer than the amount of rooms in the chosen maps,
 8, has been chosen as the last group size.
\end_layout

\begin_layout Standard
All these agent teams still need a team composition.
 With this we mean the programs the agents follow.
 While they could have differences, a heterogenous team, this might introduce
 higher order effects that would make analysis more complicated, as well
 as requiring a lot more simulations.
 While these effects might be interesting, determining the effects, if any,
 in the simple case takes priority.
 So in the interest of limiting the time spent with simulations, and analyzing
 homogenous agent teams will be used.
\end_layout

\begin_layout Subsubsection*
Communication
\end_layout

\begin_layout Standard
There are two variables to the communication, if the sending or receiving
 fails, and how often the messages fail to arrive.
\end_layout

\begin_layout Standard
When it comes to sending failure and receiving failure the difference is
 as follows: sending failure means that if a message fails no agent gets
 it but receiving failure means that some part of the team may receive it
 while other agents don't.
 The latter however increases variability between runs as the failure check
 is made for each receiving agent instead of just for the one sending agent.
 
\color red
(Explain why receiving failure corresponds more with real life scenarios
 because of dead zones.)
\end_layout

\begin_layout Standard
The failure will be constant within each simulation run and could be any
 amount between 
\begin_inset Formula $0$
\end_inset

 and a 
\begin_inset Formula $100\%$
\end_inset

 of the messages failing.
 However just like with team sizes a sampling of failure percentages will
 suffice to identify trends.
 To limit the amount of runs needed 
\begin_inset Formula $25\%$
\end_inset

 increments will be used.
 However no messages failing and all messages failing could have different
 results from only a little or a lot of messages failing.
 Therefore 
\begin_inset Formula $5\%$
\end_inset

 and 
\begin_inset Formula $95\%$
\end_inset

 will be tested as well.
 Making the complete range of tested percentages 
\begin_inset Formula $0,5,25,50,75,95,$
\end_inset

 and 
\begin_inset Formula $100\%$
\end_inset

.
\end_layout

\begin_layout Standard

\color black
One final thing to take into consideration is that the exploratory data
 has shown that without intermediate task state correction correction agent
 teams can break down fast.
 If agents can not determine that an intermediate task has already been
 completed but they missed the message even a 
\begin_inset Formula $5\%$
\end_inset

 failure can in many cases cut the amount of successful simulation runs
 in half.
 An overview of these results can be found in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:explor-success"

\end_inset

.
 This effect is so strong that it might be difficult to identify other effects
 that have less impact.
 As such agents should be written in a way that allows them to update their
 state when in the dropzone.
 In this manner agents still have a cost to missing the message without
 a single mistakenly delivered block potentially making the simulation run
 impossible to complete.
 
\color red
(Discuss if it needs to be done with both options.
 As it would just be a matter of turning this correction on or off.)
\end_layout

\begin_layout Subsection
Experiment Setup
\end_layout

\begin_layout Standard
So to summarize, the agents will do each situation with the following team
 sizes: 3, 5, 8.
 There will be 12 maps where only the block placement differs and all rooms
 are equidistant to the dropzone.
 (Chris' maps) Each agent team will attempt all maps.
 Each of these maps will be done multiple times, these repeats are grouped
 by the communication failure.
 One set of runs for 
\begin_inset Formula $0%\%
$
\end_inset

, 
\begin_inset Formula $5%\%
$
\end_inset

, 
\begin_inset Formula $25%\%
$
\end_inset

, 
\begin_inset Formula $50%\%
$
\end_inset

, 
\begin_inset Formula $75%\%
$
\end_inset

, 
\begin_inset Formula $95%\%
$
\end_inset

, 
\begin_inset Formula $100%\%
$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="8">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Team size
\backslash
failure chance
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0\%$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $5\%$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $25\%$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $50\%$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $75\%$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $95\%$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $100\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 maps
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Overview of experiment setup.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
These set of runs have repeats because of the random elements of the experiment.
 There is the agent that, when provided multiple options, takes a random
 decision and the random chance of messages not being sent.
 As there is no prior knowledge on the effects of the random components
 of the simulations, and the agents itself, a desired experimental run time
 was used to determine the amount of repetitions performed.
 Based on earlier tests and data 
\color red
(including that of Chris how to reference?)
\color inherit
 a succesful run will generally not take more than a minute.
 Using this one minute gets us 252 minutes to do everything once.
 If each agent program gets a week of runtime we can repeat the simulations
 40 times over the course of a week.
 
\color red
(Correct this based on the decision made regarding the intermediate task
 completion correction.)
\end_layout

\begin_layout Standard
The experiment itself will be set up under the following conditions:
\end_layout

\begin_layout Itemize
All the simulations will be run on identical machines.
\end_layout

\begin_layout Itemize
The simulations will be run on a dedicated machine that only has the operating
 system running in addition to the simulations.
\end_layout

\begin_layout Itemize
Only one simulation is run at the same time.
\end_layout

\begin_layout Standard
These conditions are to prevent the available processing power on the system
 from influencing simulations between runs.
 And if there is only the one simulation running on the system other processes
 can not starve it either.
 
\end_layout

\begin_layout Standard
These simulations will be run through a python script to automate the entire
 process.
 It will gather and group the logs of each set of simulations with the same
 values for the experiment dimensions.
 Every run is a new instance of the BW4T server to which a new instance
 of the runtime connects.
 This runtime will be run with only one mas file provided and a timeout.
 This is repeated for the repeat amount.
 The timeout and repeat will be the same between sets.
 The resulting data will be analysed after being converted into a csv file
 as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Research-approach"

\end_inset

.
 To reduce the amount of time needed each agent program will use a duplicated
 instance on Amazon EC2.
 As the instances are virtualised in the cloud their performance is identical
 so it will still satisfy the first condition.
 The instance will be a standard 
\begin_inset Formula $t2.micro$
\end_inset

 with only the additional software the programs needed to run the simulations
 and organise log outputs.
\end_layout

\begin_layout Standard
The log output of the BW4T server and the GOAL runtime of each simulation
 run will be packaged together for later processing once all simulation
 runs are done.
 How the logs will be processed is detailed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Analysis"

\end_inset

.
\end_layout

\begin_layout Section
Agent Design
\begin_inset CommandInset label
LatexCommand label
name "sec:Agent-Design"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename agent types.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Agent-types"

\end_inset

Agent types, each agent team has the capabilities of the previous one in
 the graph
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The agent programs are written in an iterative manner as shown in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Agent-types"

\end_inset

.
 There is one base agent team consisting of one agent and the following
 agent teams build upon that by adding different forms of communication.
 For communication we need multiple agents so all agent teams except for
 the base team will have multiple agents.
 The communication methods are added in 3 iterations.
 
\series bold
The last iteration implements 2 variants so there are 5 different agent
 teams an overview of which is given in figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Agent-types"

\end_inset

.

\series default
 The single agent team acting as the baseline for the performance of the
 other agent teams.
 Each of the 5 agent programs will be discussed below.
 The baseline agent defines the default behaviour of the agent and the following
 sections specify what form of communcation is added and how this affects
 the behaviour.
 Because it is a single agent the resulting task completion data can also
 be used as a baseline for determining how effective the communication is
 in improving the agents.
 The full code for the agents can be found in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "appendix:Goal-Agents-Source"

\end_inset

.
\end_layout

\begin_layout Subsection
Baseline Agent
\begin_inset CommandInset label
LatexCommand label
name "sub:Baseline-Agent"

\end_inset


\end_layout

\begin_layout Standard
The baseline agent team is a single agent performing a random exploration
 algorithm.
 It remembers which rooms are explored and the blocks that present.
 The exploration is interrupted by a greedy delivery algortihm when it finds
 a room with a block of the current colour in the sequence.
 When the block is delivered it will check if it knows where the next colour
 is located and deliver that too.
 If there are more blocks of the same colour it will choose one at random.
 If the agent has not found blocks of the right colour yet it will return
 to the exploration algorithm.
 Because it only delivers blocks that are of the current colour in the sequence
 and is the only agent it is garuanteed to always succeed in the maps defined
 in the experiment design subsection
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Experiment-reduction"

\end_inset

.
\end_layout

\begin_layout Standard
The agent achieves this by performing the following steps:
\end_layout

\begin_layout Itemize
First the events module processes all percepts it receives from the environment
 to update its beliefs.
 
\end_layout

\begin_layout Itemize
With the updated beliefs it determine if the current goals are still possible
 and relevant.
 If not the goals are dropped.
 This will never happen with a single agent as it is the only entity affecting
 the environment but the step exists so derivative agents can do it when
 necessary.
\end_layout

\begin_layout Itemize
If the agent has a goal to deliver a block it goes into the adoptDeliverGoals
 module which provides the intermediate goals to get the block delivered
 to the dropzone.
\end_layout

\begin_layout Itemize
If there is no block to be delivered at this moment in time it goes into
 the adoptExplorationGoals module.
 This provides the goals to implement the greedy exploration algorithm described
 earlier in the section and the goal to deliver a block if the right colour
 is found.
\end_layout

\begin_layout Itemize
Then the agent goes into the main module which performs the actions correspondin
g to the various goals.
\end_layout

\begin_layout Itemize
Finally, if the agent has delivered the entire sequence it stops.
\end_layout

\begin_layout Standard

\series bold
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename agent flow.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
\begin_inset Caption Standard

\begin_layout Plain Layout
A high level flow diagram of the agent modules.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The goal modules and the main module will be discussed in more detail below.
 The percepts will not be discussed as they are available in appendix
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Code:No-Communication-Agent"

\end_inset

 and further clarification of the details can be found in the BW4T specification.
 The evaluation of the goals is skipped because there are no other agents
 yet that can influence the environment as well.
\end_layout

\begin_layout Subsubsection*

\lang british
adoptExplorationGoals
\end_layout

\begin_layout Standard
First we look at the adoptExplorationGoals module.
 The way we indicate that we want to go to a room is with the 
\begin_inset Formula $in(Place)$
\end_inset

 goal.
 The main module reacts to this by going to a room with the name 
\begin_inset Formula $Place$
\end_inset

.
 Once the agent is in that room we get a percept and process it to fulfill
 the goal.
 The way we adopt the
\begin_inset Formula $in(Place)$
\end_inset

 goal in this module provides the exploration behaviour:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if bel( room(Place), not(dropZone(Place)), not(visited(Place)) ) then adopt(
 in(Place) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This rule looks at all rooms that are not the dropzone, this is the location
 where the blocks have to delivered in BW4T, where the blocks will be delivered.
 The agent learns of these locations when it is initialised.
 If those rooms are entered for the first time adds a 
\begin_inset Formula $visited(Place)$
\end_inset

 belief in the events module.
 This belief lets the agent exclude visited rooms for future exploration
 goals.
 
\end_layout

\begin_layout Standard
Without additional configuration this rule would not implement a 
\shape italic
random 
\shape default
exploration however.
 To achieve this the module has to use linear random order to check its
 rules.
 
\series bold
This execution order means that the various rules in the module are executed
 in linear order, stopping after the first rule that succeeds.
 When evaluating a rule random valid options for the variables are be chosen
 from all valid options.
 In the rule above that means that it chooses 
\begin_inset Formula $Place$
\end_inset

 at random from all 
\begin_inset Formula $room(Place)$
\end_inset

 beliefs instead of always choosing the first in the belief base.
 
\series default
This differs from the default, linear order, which pick the first valid
 option in the belief base instead.
\end_layout

\begin_layout Standard
The module contains another rule to determine if it has found the next block
 in the sequence.
 Because the module uses linear random order this rule has been placed at
 the start of the module so delivering blocks takes precedence over exploring.
 
\series bold
The following rule is the end result of the agent team iterations so it
 is more complex than strictly necessary for the baseline agent team.
 The reason the rule is in this form is because the agents share code to
 ensure they are the same aside from the communication.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if a-goal(sequence(Seq)), bel( agentCount(N), nextXColoursInSeq(Colors,
 N, Seq),
\end_layout

\begin_layout Plain Layout

	findall(ColorID, (delivering(_,ABlock), block(ABlock, ColorID, _)), TakenC),
\end_layout

\begin_layout Plain Layout

	single_subtract(Colors, TakenC, UntakenC), member(Color, UntakenC),
\end_layout

\begin_layout Plain Layout

	block(BlockID, Color, Place), not(Place = held) ) then adopt( delivered(BlockID
) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
However for the baseline agent this rule can be respresented in a simpler
 form.
 Here just the simple version will be explained and the rule will be discussed
 again in subsection
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Room-and-block"

\end_inset

 and subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Proactive/reactive-action-coordi"

\end_inset

 below to explain the rest.
 
\series default
Introducing the more complex aspects as they become relevant for the discussed
 agent team.
 At this point in discussing the agents the rule can actually be represented
 by the following simplified form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if a-goal(sequence(Seq)), bel( nextXColoursInSeq([Color], 1, Seq),
\end_layout

\begin_layout Plain Layout

	block(BlockID, Color, _) ) then adopt( delivered(BlockID) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As long as we still have a sequence of colours to be delivered it gets the
 first colour of the sequence that hasn't been delivered yet.
 This is done by using the 
\begin_inset Formula $nextXColoursInSeq(ColourList,X,Seq)$
\end_inset

 predicate.
 
\begin_inset Formula $ColourList$
\end_inset

 is the list of the first 
\begin_inset Formula $X$
\end_inset

 colours in the sequence excluding the blocks that already have been delivered.
 As 
\begin_inset Formula $X=1$
\end_inset

 the predicate always returns the colour that needs to be delivered at this
 moment.
 
\end_layout

\begin_layout Standard
Then the rule selects a random block from the the ones that were found in
 all visited rooms with the same color and adopts the goal to have it delivered.
 This goal does nothing on its own but is used by adoptDeliverGoals module
 to provide the intermediary goals.
 The reason that the block chosen is random is that going for the closest
 block will involve an additional path-finding algorithm in case after deliverin
g there are multiple blocks of the same colour.
 The agent is purposely kept simple so we chose not to implement that.
\end_layout

\begin_layout Standard
If there are no blocks of the right colour the rule fails and will return
 to the random exploration described earlier.
\end_layout

\begin_layout Subsubsection*
adoptDeliverGoals
\end_layout

\begin_layout Standard
The delivery algorithm works in a similar manner.
 It also contains rules that are only relevant for later agent teams so
 they will be discussed in the relevant subsections.
 For the baseline agent we will look at two rules, the first is delivering
 a block to the dropzone if the agent holds it, and the other is getting
 to the block that needs to be delivered to pick it up.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\align left

if a-goal(sequence(Seq)), bel( holding(BlockID), nextColorInSeq(Color, Seq),
 block(BlockID, Color, _), 	dropZone(Place) ) then adopt( in(Place) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once again it shares code with later agents so for the baseline agent we
 examine it in a simpler form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\align left

if bel( holding(BlockID), dropZone(Place) ) then adopt( in(Place) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
If we<-the agent is> are holding the block and we know a dropzone
\series default
, adopt the goal to go there.
 The 
\begin_inset Formula $BlockID$
\end_inset

 is passed to the module as a parameter so this rule will not trigger if
 the agent is holding a block that it does not need to deliver.
 The main module is responsible for dropping the block once the agent is
 in the dropzone.
\end_layout

\begin_layout Standard
Getting to the block makes use of the 
\begin_inset Formula $BlockID$
\end_inset

 variable as well to determine the room the block is in.
 Then adopt the 
\begin_inset Formula $in$
\end_inset

 goal so the main module goes there.
 The main module then makes sure to pick up the block once the agent is
 in the room.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\align left

if bel( not(holding(BlockID)), block(BlockID, _, Place) ) then adopt( in(Place)
 ).
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
main
\end_layout

\begin_layout Standard
Where the goal modules are about the agents reasoning, the main module acts
 on it.
 The order of the rules in this module matters as it determines the priority
 of what needs to be done.
 As such this module performs the rules in linear order.
\end_layout

\begin_layout Standard
The first rule is delivering the block the agent holds if it is in the dropzone
 and still holding the block.
 Delivering here means putting down the block and going into the updateSequence
 module.
 This module updates the 
\begin_inset Formula $sequence$
\end_inset

 belief to include the colour of the block just delivered.
 And it removes the block from the beliefs to prevent the agent from trying
 to deliver the block again.
\end_layout

\begin_layout Standard
Then if the agent is in a room with the block it wants to deliver it should
 move towards the block and do the goToBlock block action.
 This will fail if the agent is already at the block.
 This is followed by a separate rule that attempts to pick up the block
 if it is not holding anything.
\end_layout

\begin_layout Standard
Finally the agent checks if there are any 
\begin_inset Formula $in(Place)$
\end_inset

 goals and if there are it performs a goto action to go there.
 If the agent is already moving somewhere the goto action fails.
\end_layout

\begin_layout Subsection
Simple agent team
\end_layout

\begin_layout Standard
The first step to introduce communication to a single agent would be the
 same agent but with several in the agent team.
 With one change to guarantee that they would always be able to finish the
 task.
 The agents need to be informed when the current block in the sequence has
 been delivered.
 If the agents do not know what the other agents have done they would attempt
 to do the entire sequence on their own.
 This can make it impossible to finish instances if there are not enough
 blocks of each colour to do the sequences in parallel.
 All blocks delivered to the dropzone disappear from the environment so
 they can not be reused later.
 So in case a block is needed more than once in a sequence the agents can
 never finish if all blocks of a certain colour are delivered before they
 are needed.
\end_layout

\begin_layout Standard
The agents can be informed of what the other agents have delivered in several
 ways, which have been discussed in subsection
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Experiment-reduction"

\end_inset

 in the part about communication.
 In our case we decided on having the agent sending a message to all other
 agents whenever it delivers a block to the dropzone.
 The communication clause added to the rule is the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

allother.send( msg(delivered(BlockID)) )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The message is processed by the 
\series bold
new
\series default
 comBasic module that is performed before any of the steps the baseline
 agent takes.
 The module will then perform the updateSequence module as in the main module
 but with the BlockID received in the message.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

forall (Agt).sent(msg(delivered(BlockID))) do updateSequence(BlockID).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here the benefit of removing the blocks in the updateSequence module shows
 itself.
 The receiving agent might have seen the same block in a room before and
 still believe it is there.
 If this belief is not updated it will get stuck trying to deliver a block
 that no longer exists.
\end_layout

\begin_layout Standard
When an agent receives 
\begin_inset Formula $msg(deliveryDone(BlockID))$
\end_inset

 there are four situations it could be in;
\end_layout

\begin_layout Itemize
The agent is holding a block and its colour is the next colour in the sequence.
 It will continue trying to deliver the block.
\end_layout

\begin_layout Itemize
The agent is not holding anything and trying to pick up a block.
 If the next colour in the sequence is the same as before the agent will
 continue.
\end_layout

\begin_layout Itemize
The agent is holding a block and its colour is not the next colour in the
 sequence.
 In that case the agent follows the baseline exploration algorithm as described
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Baseline-Agent"

\end_inset

 with one difference.
 The first time it enters a room it will drop the block it is holding.
 This is to prevent the risk of losing a block that is needed later because
 all blocks dropped outside of a room will disappear from the environment.
\end_layout

\begin_layout Itemize
The agent is not holding anything and the conditions above do not hold.
 In that case the agent continues to follow the baseline exploration algorithm
 as described in section
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Baseline-Agent"

\end_inset

.
\end_layout

\begin_layout Standard
There is one situation where this can cause a deadlock.
 When the agent is without options while in the dropzone.
 It has already explored all rooms but due to the moving around of blocks
 by other agents it is not aware where the next needed block might be.
 So it will not go anywhere.
 There is nothing it can do but at least one of the other agents does know.
 The agent that moved the relevant block.
 That agent can not deliver it however because only one agent can be in
 a room at any given time.
 So the delivering agent has to wait for the dropzone to be vacated but
 that will never happen.
 To prevent this an additional line as been added at the end of the adoptGoals
 module:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if bel( dropZone(Place), in(Place) ) then adopt( at('FrontDropZone') ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With these changes agents should now always complete the scenario.
 After all, the dropzone will always become available for the next delivery,
 and there is always at least one agent that knows the location of any given
 block if a room has been visited.
 And no blocks will be incorrectly delivered as the agents share their progress.
 From here the agents follow the same algorithm as the baseline agent so
 there is always one agent that can deliver the next block.
 However the deadlock we discussed shows that there is still room for performanc
e improvement.
\end_layout

\begin_layout Subsection
Room and block coordination agent team
\begin_inset CommandInset label
LatexCommand label
name "sub:Room-and-block"

\end_inset


\end_layout

\begin_layout Standard
Like the deadlock described above it can also happen that an agent will
 enter a room expecting a block to be there and not find it.
 This will update its knowledge on what is present in the room but it won't
 know where to find the block.
 If it doesn't know of any other blocks of the desired colour it will return
 to the exploration algorithm.
 If all rooms have already been visited it has no way to find where the
 block ended up.
 This is not a deadlock as one agent will still know the block location
 but through communication the additional wait can be avoided.
 
\end_layout

\begin_layout Standard
The agent team does this by introducing the comBlocks module.
 This module sends a message for each block it sees for which it gets new
 information and also processes those messages it gets from other agents.
 This happens before the events module.
 This means that not only do the agents send updates when a block is put
 down in a different room but also that a message is sent the first time
 a block is seen.
 This is not something we want to avoid as it can be used to further optimize
 the agent.
 The agent receives the information on blocks others have found and can
 use that to determine if there is a block it can deliver.
\end_layout

\begin_layout Standard
The code below ensures that all agents in the team listen for updates on
 block locations.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

forall (Agt).sent( msg(block(BlockID, ColorID, Place)) ), bel( block(BlockID,
 ColorID, OtherPlace),
\end_layout

\begin_layout Plain Layout

	Place 
\backslash
= OtherPlace ) do delete( block(BlockID, ColorID, OtherPlace) ) +
\end_layout

\begin_layout Plain Layout

	insert( block(BlockID, ColorID, Place) ).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

forall (Agt).sent( msg(block(BlockID, ColorID, Place)) ), bel( not(block(BlockID,
 ColorID, Place)) )
\end_layout

\begin_layout Plain Layout

	do insert( block(BlockID, ColorID, Place) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These two lines process 
\begin_inset Formula $block$
\end_inset

 messages for two possible cases, the first updates block location information
 in the case an agent already knows of a block with the same ID.
 The second line inserts beliefs for blocks the agent was unaware of.
 This pattern prevents duplicate blocks where the location differs.
\end_layout

\begin_layout Standard
The agents also share if they are holding a block to prevent other agents
 from trying to pick up a block that was already grabbed.
 It updates the 
\begin_inset Formula $Place$
\end_inset

 for the 
\begin_inset Formula $block(BlockID,ColorID,Place)$
\end_inset

 predicate to 'held' once an agent picks up the block.
 Once the agent drops the block it is either removed by 
\begin_inset Formula $BlockID$
\end_inset

 through the updateSequence module or because the agent sees that the block
 is now present in the room.
 Seeing the block in the room updates the location again as described above.
 Agents only see blocks that are put down in a room.
 Below is the code showing how the 
\begin_inset Formula $heldblock(BlockID)$
\end_inset

 message that the agents use to communicate this is processed:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

forall (Agt).sent( msg(heldblock(BlockID)) ), bel( block(BlockID, ColorID,
 Place) )
\end_layout

\begin_layout Plain Layout

 		do delete( block(BlockID, ColorID, Place) ) + insert( block(BlockID,
 ColorID, held) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One thing to note is that the adoptExplorationGoals module has an addition
 because of this change.
 A condition is added to the rule that adopts the 
\begin_inset Formula $delivered$
\end_inset

 goals to make sure the block the agent tries is not already held by another
 agent.
 However the block can still be picked up between adopting the goal and
 getting to the block.
 This will cause the agent to try and deliver a block it can not locate
 so we added a rule to drop the 
\begin_inset Formula $delivered$
\end_inset

 goal when that occurs.
\end_layout

\begin_layout Standard
Finally because the agents already share the information on blocks the agents
 do not need to visit rooms that other agents have visited.
 They already know which blocks are in there.
 Therefore this agent team also introduced the comVisited module to stop
 agents from visting rooms they do not need to.
 This module sends a message when an agent visits a room for the first time.
 While this information could be derived from block communication this provides
 more clarity in what the communication is intended for.
 The message sent is identical to the 
\begin_inset Formula $visited(Place)$
\end_inset

 belief used by the baseline exploration algorithm and treated the same
 by the receiving agents.
\end_layout

\begin_layout Subsection
Proactive/reactive action coordination agent teams
\begin_inset CommandInset label
LatexCommand label
name "sub:Proactive/reactive-action-coordi"

\end_inset


\end_layout

\begin_layout Standard
The communication added in section
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Room-and-block"

\end_inset

 leaves one situation where an agent would do nothing.
 When all rooms have been visited and there is only one block of the current
 colour in the sequence.
 If another agent has already picked up the block it will wait until it
 can do something again.
 This is because all agents are trying to go for the same block in the sequence
 instead of dividing the work.
\end_layout

\begin_layout Standard
The final two agent teams implement nearly identical planning algorithms
 to divide the work.
 The reason there are two teams is because we have identified two ways the
 agent teams can coordinate which affects the way they communicate.
 These two methods should have similar results when the communication has
 no failures but could have different performances once failures are introduced.
 The full details on how the communication is done for each team is discussed
 below.
 Before that the parts of the algorithm that are the same are discussed.
\end_layout

\begin_layout Standard
The teams both communicate which block they intend to deliver to the other
 agents.
 The communication they share is part of the lookahead module.
 This is where the agents communicate the intent to deliver a block and
 also if the agent no longer intents deliver a block for any reason.
\end_layout

\begin_layout Standard
The adoptExplorationGoals module has a rule to adopt the 
\begin_inset Formula $deliver(BlockID)$
\end_inset

 goal and follows the following steps: if the current colour is already
 being delivered the agent will behave as if that colour has already been
 delivered, and so on for each colour that an agent is delivering.
 If an agent has been working ahead it will wait with the block in front
 of the dropzone until it should be delivered.
\end_layout

\begin_layout Standard
To understand how this is done specifically we look again at the rule we
 also showed in subsection
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Baseline-Agent"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if a-goal(sequence(Seq)), bel( agentCount(N), nextXColoursInSeq(Colors,
 N, Seq),
\end_layout

\begin_layout Plain Layout

	findall(ColorID, (delivering(_,ABlock), block(ABlock, ColorID, _)), TakenC),
\end_layout

\begin_layout Plain Layout

	single_subtract(Colors, TakenC, UntakenC), member(Color, UntakenC),
\end_layout

\begin_layout Plain Layout

	block(BlockID, Color, Place), not(Place = held) ) then adopt( delivered(BlockID
) ).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First we look at 
\begin_inset Formula $agentCount(N)$
\end_inset

.
 This predicate only returns the amount of agents if on initialization the
 agent added the 
\begin_inset Formula $lookahead$
\end_inset

 belief.
 Otherwise it returns 1.
 That's why the previous agents only attempt to deliver the current colour
 in the sequence.
\end_layout

\begin_layout Standard
Then 
\begin_inset Formula $NextXColoursInSeq(Colors,N,Seq)$
\end_inset

 gives us list of the colours as 
\begin_inset Formula $Colors$
\end_inset

 that still need to be delivered to a maximum of 
\begin_inset Formula $N$
\end_inset

 colours.
 It could be less in case there are less than 
\begin_inset Formula $N$
\end_inset

 colours to be delivered.
 This is combined with the list 
\begin_inset Formula $TakenC$
\end_inset

 which is the list of all colours we know another agent is trying to deliver.
 The list is created by finding all 
\begin_inset Formula $delivering(Agent,BlockID)$
\end_inset

 beliefs and getting the corresponding colours.
\end_layout

\begin_layout Standard
The list 
\begin_inset Formula $Colors$
\end_inset

 then has the list 
\begin_inset Formula $TakenC$
\end_inset

 subtracted from it, this list is called 
\begin_inset Formula $UntakenC$
\end_inset

, leaving only the colours no other agent is delivering.
 Each colour already being delivered is only subtracted once in case there
 are duplicate colours in the sequence.
 The agents should not skip a colour entirely because one block of the relevant
 colour is already being delivered.
\end_layout

\begin_layout Standard
The agent then picks a random element from 
\begin_inset Formula $UntakenC$
\end_inset

 which is the colour it will try to deliver.
 The rule then follows the same principles as with the baseline agent with
 the addition for held blocks.
\end_layout

\begin_layout Paragraph
4.4a Reactive action coordination agent team
\end_layout

\begin_layout Standard
This team is called reactive because the agent sends a message broadcasting
 which block it wants to deliver but does not act on it.
 Then the agent reacts to the other agents in the team telling it what to
 do.
 Only if all agents give it the okay will start on the common algorithm
 described above.
\end_layout

\begin_layout Standard
If another agent planned the same goal, it resolves the conflict using the
 following method: compare the agent names assigned by the BW4T environment
 through string comparison.
 If the other agent's name is larger that agent gets to deliver the block.
 The agent doing the check informs the original agent by sending a dismissal.
 The original agent will in turn confirm the plan of the agent with the
 larger name as its name is smaller.
\end_layout

\begin_layout Standard
The above steps are done after the adoptGoals steps in the baseline agent.
 Because it needs the latest information to make the decision.
\end_layout

\begin_layout Paragraph*
4.4b Proactive action coordination agent team
\end_layout

\begin_layout Standard
Where the reactive agent team waits the proactive agent team acts first
 and verifies later.
 The team proactively adopts the goal first and then verifies that nobody
 else is doing the same.
 It uses the same conflict resolution method as the reactive team but it
 drops the goal once it is informed another agent declined its plan.
 This needs less information as an agent only needs to be informed when
 another agent declines the goal.
\end_layout

\begin_layout Standard
The above steps are done after the adoptGoals steps in the baseline agent.
 Because it needs the latest information to make the decision.
\end_layout

\begin_layout Section
Analysis
\begin_inset CommandInset label
LatexCommand label
name "sec:Analysis"

\end_inset


\end_layout

\begin_layout Standard
Data points to analyse: amount of succesful runs, time of successful runs
 (less reliable since we expect to have less successes), amount of blocks
 returned to rooms (incorrect/unnecessary blocks), difference between the
 dropzone correction and without.
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:com-effects-succes-fail"

\end_inset

 gives us an overview of what was expected to happen in the various scenarios.
 While even the guaranteed successful scenarios might not finish within
 the timeframe given for the experiments they should more often do so than
 in scenarios where success might not always be possible.
 In these cases different strategies can be compared for how much they slow
 down compared to the reference and what the major causes for slowdown are.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Success Guaranteed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Could fail
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sequenceUpdate broadcast fails: wrong blocks delivered and lost
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
room/block information broadcast fails: slows down
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Agent Intention Broadcast: slows down
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Agent plan negotiation message failure: Might wait for permission forever
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:com-effects-succes-fail"

\end_inset

Table of the effects communication failure might have.
 On the left success is guaranteed if given time.
 On the right situations may arise where success is no longer possible.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The types of communication that can cause failure do this for different
 reasons.
 The first does this by incorrect information, the place in the sequence,
 leading to wasting resources and making the task impossible.
 The second one does it by having the agent logic deadlock and cause them
 to not do anything.
 It should be noted that in the second case it is theoretically possible
 to still finish as opposed to the first situation.
 {{Does this mean anything? Like make it more important to fix as it is
 only limited by programming?
\end_layout

\begin_layout Section
Mitigation Strategies
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesis"
options "plain"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Goal Agents Source
\begin_inset CommandInset label
LatexCommand label
name "appendix:Goal-Agents-Source"

\end_inset


\end_layout

\begin_layout Standard
The agent teams each have their own main module.
 However a lot of the other modules are shared as they share capabilities.
 First the different agents are detailed.
 Then the shared modules and knowledge.
\end_layout

\begin_layout Subsection
No Communication Agent
\begin_inset CommandInset label
LatexCommand label
name "sub:Code:No-Communication-Agent"

\end_inset


\end_layout

\begin_layout Standard
This agent does not communicate and serves as the basis for both the single
 agent team and the no communication multiple agents team.
 The only difference between the two is the amount of agents instantiated
 by the .mas file.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use robot as knowledge.
 
\end_layout

\begin_layout Plain Layout

use robot as actionspec.
 
\end_layout

\begin_layout Plain Layout

use updateSequence as module.
 
\end_layout

\begin_layout Plain Layout

exit=nogoals.
\end_layout

\begin_layout Plain Layout

module main { 	
\end_layout

\begin_layout Plain Layout

	%drop blocks in the dropzone when they are needed, and communicate this.
\end_layout

\begin_layout Plain Layout

	if bel(in('DropZone'), holdingNextBlock) then putDown + updateSequence.
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	%drop blocks in rooms when they are not needed anymore
\end_layout

\begin_layout Plain Layout

	if bel(in(Loc),Loc
\backslash
='DropZone', not(holdingNextBlock)) then putDown.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	%go to goal places
\end_layout

\begin_layout Plain Layout

	if a-goal(in(Place)) then goTo(Place).
 	
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	%go to goal blocks
\end_layout

\begin_layout Plain Layout

	if a-goal(holding(BlockID)), bel(in(Place), block(BlockID,_,Place), not(atBlock
(BlockID))) then goToBlock(BlockID).
 	
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	%pickup goal blocks 	
\end_layout

\begin_layout Plain Layout

	if a-goal(holding(BlockID)), bel(atBlock(BlockID)) then pickUp.		 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
events.mod2g
\begin_inset CommandInset label
LatexCommand label
name "code:events.mod2g"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use robot as knowledge.
\end_layout

\begin_layout Plain Layout

use robotGoals as module.
\end_layout

\begin_layout Plain Layout

use updateSequence as module.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module robotEvents {
\end_layout

\begin_layout Plain Layout

	%-------communication updates & conclusions about other agents-------
\end_layout

\begin_layout Plain Layout

	forall bel( send('allother', Y) ) do allother.send(msg(Y)) + delete(send('alloth
er', Y)).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% deduce information based on deliveries of other agents:
\end_layout

\begin_layout Plain Layout

	forall (Agt).sent(msg('deliveryDone')) do updateSequence.
 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	% Update the agent's state of movement.
\end_layout

\begin_layout Plain Layout

	forall bel( state(State)), percept(state(NewState)) do delete( state(State)
 ) + insert( state(NewState) ).
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Record when we are entering or leaving a room.
\end_layout

\begin_layout Plain Layout

	forall percept(in(Place)) do insert( in(Place) ).
\end_layout

\begin_layout Plain Layout

	forall percept(in(Place)), bel( not(visited(Place)), room(Place) ) do insert(
 visited(Place) ).
\end_layout

\begin_layout Plain Layout

	forall percept(not(in(Place))) do delete( in(Place)).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Discover new blocks
\end_layout

\begin_layout Plain Layout

	forall percept(color(BlockID, ColorID)), bel( in(Place), not(block(BlockID,
 ColorID, Place)) ) do insert( block(BlockID, ColorID, Place) ).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Record atblock location of agent
\end_layout

\begin_layout Plain Layout

	forall percept(atBlock(BlockID)) do insert(atBlock(BlockID)).
\end_layout

\begin_layout Plain Layout

	forall percept(not(atBlock(BlockID))) do delete(atBlock(BlockID)).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Record if a block is being held
\end_layout

\begin_layout Plain Layout

	forall percept(holding(BlockID)) do insert(holding(BlockID)).
\end_layout

\begin_layout Plain Layout

	forall percept(not(holding(BlockID))) do delete(holding(BlockID)).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	%remove blocks that are not held or in the room anymore
\end_layout

\begin_layout Plain Layout

	forall bel(in(Place), block(BlockID, ColorID, Place), not(holding(BlockID))),
 not(percept(color(BlockID, ColorID))) do delete(block(BlockID, ColorID,
 Place)).
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

	%remove blocks that are not held or in the room anymore
\end_layout

\begin_layout Plain Layout

	forall bel(in(Place), block(BlockID, ColorID, Place), not(holding(BlockID))),
  not(percept(color(BlockID, ColorID))) do delete(block(BlockID, ColorID,
 Place)).
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	% Update sequence when in dropzone.
\end_layout

\begin_layout Plain Layout

	if percept(sequenceIndex(X)), bel(sequenceIndex(OldX)) then delete(sequenceInde
x(OldX)) + insert(sequenceIndex(X)).
\end_layout

\begin_layout Plain Layout

	if bel( in('DropZone'), seqDone(Seq), length(Seq, N), sequenceIndex(X),
 N < X ,  sequence(NewSeq), length(NewSeq, X), append(NewSeq, _, Full) )
 then delete( seqDone(Seq) ) + insert( seqDone(NewSeq) ).
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	%remove obsolete goals
\end_layout

\begin_layout Plain Layout

	if goal(holding(BlockID)), bel(not(block(BlockID, ColorID, Place))) then
 drop(holding(BlockID)).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	%adopt new goals (and stop traveling)
\end_layout

\begin_layout Plain Layout

	if not(goal(in(Place))), goal(seqDone(_)) then adoptgoals.
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Common Code
\end_layout

\begin_layout Standard
robot.act2g:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use robot as knowledge.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% The goTo action makes the agent move to a place (location) in the BW4T
 environment.
 
\end_layout

\begin_layout Plain Layout

% As long as the agent has not arrived at the place it is going to, it will
 be in "traveling" mode.
 
\end_layout

\begin_layout Plain Layout

define goTo(Location) with
\end_layout

\begin_layout Plain Layout

	pre { not(state(traveling)) }
\end_layout

\begin_layout Plain Layout

	post { true }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% goToBlock only when not traveling and in a room 
\end_layout

\begin_layout Plain Layout

define goToBlock(BlockID) with
\end_layout

\begin_layout Plain Layout

    pre {in(_), not(state(traveling)) }
\end_layout

\begin_layout Plain Layout

	post { true }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% pickUp can only be performed when not holding a block 
\end_layout

\begin_layout Plain Layout

define pickUp with
\end_layout

\begin_layout Plain Layout

	pre{not(state(traveling)), not(holding(_))}
\end_layout

\begin_layout Plain Layout

	post{ true }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% putDown can only be performed when holding a block 
\end_layout

\begin_layout Plain Layout

define putDown with
\end_layout

\begin_layout Plain Layout

	pre{not(state(traveling)), holding(_)}
\end_layout

\begin_layout Plain Layout

	post{ true } 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
UpdateSequence.mod2g
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use robot as knowledge.
 order=linearall.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module updateSequence{
\end_layout

\begin_layout Plain Layout

	%update sequence 	
\end_layout

\begin_layout Plain Layout

	if bel(seqDone(SDone), nextNeededColor(ColorID), append(SDone,[ColorID],NewSDon
e) ) then delete(seqDone(SDone)) + insert(seqDone(NewSDone)).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	%remove beliefs about the delivered block (if this agent was delivering
 it)
\end_layout

\begin_layout Plain Layout

	if bel(in('DropZone'), holding(BlockID), block(BlockID, ColorID, Place))
 then delete(block(BlockID, ColorID, Place)).
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
robotGoals.mod2g
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use robot as knowledge.
 order=linear.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module adoptgoals{
\end_layout

\begin_layout Plain Layout

	%If holding the next needed block go to the dropzone.
\end_layout

\begin_layout Plain Layout

	if bel( holding(BlockID), nextNeededColor(ColorID), block(BlockID, ColorID,
 _)) then adopt(in('DropZone')).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	%Otherswise, If the next needed block is known then adopt a goal to go
 there and hold it.
\end_layout

\begin_layout Plain Layout

 	if bel( nextNeededColor(ColorID), block(BlockID, ColorID, Place)) then
 adopt(in(Place),holding(BlockID)).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	%Otherwise go to a random room we haven't seen yet'.
\end_layout

\begin_layout Plain Layout

	if bel( not(finished), bagof(Place, (room(Place), not(dropZone(Place))),
 Places), random_member(Dest, Places) ) then adopt(in(Dest)).
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
robotInit.mod2g
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

use robot as knowledge.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

module robotInit {
\end_layout

\begin_layout Plain Layout

	% Store map information, i.e., navigation points in the agent's belief base.
\end_layout

\begin_layout Plain Layout

	forall percept(zone(ID, Name, X, Y, Neighbours)) do insert( zone(ID, Name,
 X, Y, Neighbours) ).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Record the initial state of movement in belief base.
\end_layout

\begin_layout Plain Layout

	if percept(state(State)) then insert( state(State) ).
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	% Record goal sequence
\end_layout

\begin_layout Plain Layout

	if percept( sequence(Seq) ) then insert(sequence(Seq), seqDone([])) + 
 adopt(seqDone(Seq)).
\end_layout

\begin_layout Plain Layout

	if percept( sequenceIndex(X) ) then insert( sequenceIndex(X) ).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Adopt initial goal going to a random place
\end_layout

\begin_layout Plain Layout

	if bel(room(PlaceID), PlaceID
\backslash
='DropZone') then adopt(in(PlaceID)).
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exploratory research data
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="9">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Agents
\backslash
chance of failure
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reference
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
communication cuttoff
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
95%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50% send failure
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blockbuster Mincom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
193
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
109
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
74
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
63
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blockbuster dzone only
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
199
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blockbuster all room
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
190
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
85
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
52
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Maximum Coordination
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
188
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
168
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
182
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
182
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
162
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
138
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:explor-success"

\end_inset

The amount of successes over 200 runs per agent per failure mode.
 All agent and failure mode combinations resulted in a chi square 
\begin_inset Formula $p<0.01$
\end_inset

 except for Coordination at 5%(
\begin_inset Formula $p\thickapprox0.07)$
\end_inset

 The entries marked with * have been performed with fewer than 200 runs
 and scaled up to the same amount so less accurate.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
